# מסמך אפיון פורמלי – מערכת ניטור וניתוח גיבויים (שב"א)

## 1. מבוא ומטרות

### 1.1 רקע עסקי

שב"א מפעילה מערכות קריטיות המחייבות זמינות גבוהה, עמידה ב־SLA, ובקרה הדוקה על תהליכי הגיבוי. כיום קיים קושי לקבל תמונה אחודה, השוואתית והיסטורית של ביצועי הגיבויים, זיהוי חריגות בזמן, והפקת דוחות נגישים לגורמים טכנולוגיים וניהוליים.

### 1.2 מטרת המערכת

פיתוח מערכת מרכזית לאיסוף, סיווג, עיבוד, ניתוח והצגת נתוני גיבויים, באופן מודולרי וגמיש, כך שתתמוך:

* בניתוח יומי, תקופתי והיסטורי
* בזיהוי חריגות חכם
* בהצגת נתונים בדוחות וב־Dashboard
* באינטגרציה עתידית לממשקים וכלי ניטור נוספים

### 1.3 קהל יעד

* צוותי IT ותשתיות
* מנהלי מערכות
* גורמי ניהול ובקרה
* אינטגרציות עתידיות (חברות נוספות)

---

## 2. עקרונות ארכיטקטוניים

### 2.1 עקרונות מנחים

* הפרדת אחריות (Separation of Concerns)
* ארכיטקטורה מודולרית
* הרחבה ללא שינוי לוגיקה קיימת (Open/Closed)
* תמיכה בריבוי צרכנים (UI / API / Monitoring)

### 2.2 מבנה לוגי כללי

```
[Data Sources]
      |
      v
[Data Loader]
      |
      v
[Classification Layer]
      |
      v
[Processing & Analytics Engine]
      |
      +--> [Anomaly Detection]
      |
      v
[Reporting Layer]
      |
      +--> CSV / JSON / HTML
      |
      v
[Presentation Layer]
      +--> Internal UI
      +--> External Monitoring Tools
```

---

## 3. רכיבי מערכת

### 3.1 Data Loader

**אחריות:**

* טעינת נתוני גיבויים ממקורות חיצוניים (לוגים, קבצים, APIs)
* נרמול נתונים לפורמט פנימי אחיד

**קלט:** Raw Backup Records
**פלט:** Normalized Backup Events

---

### 3.2 Classification Layer (שכבת סיווג)

**מטרה מרכזית:**
סיווג ברור, קריא וניתן להרחבה של סוגי הגיבויים

**מאפיינים:**

* שכבה ייעודית ונפרדת
* מימוש מבוסס Strategy / Registry
* תמיכה בהוספת סוגי גיבוי ללא שינוי קוד קיים

**פלט:**

* BackupType
* Metadata ייעודי לסוג הגיבוי

---

### 3.3 Processing & Analytics Engine

**אחריות:**

* חישוב משכי גיבוי
* חיתוכים יומיים, שבועיים, חודשיים
* השוואות בין תקופות:

  * יום מול יום
  * שבוע מול שבוע
  * חודש מול חודש

**יכולות:**

* חישוב ממוצעים, חציון, סטיית תקן
* שמירת נתונים היסטוריים לצורך מגמות

---

### 3.4 Anomaly Detection

**מטרה:** זיהוי גיבויים חריגים ביחס להתנהגות ההיסטורית

**שלב ראשון (Rule-Based):**

* חריגה מזמן ממוצע + סף
* חריגה מגודל קובץ

**שלב מתקדם (אופציונלי):**

* שימוש במודלים סטטיסטיים / ML
* זיהוי דפוסים לא צפויים לאורך זמן

---

### 3.5 Reporting Layer

**אחריות:** הפקת דוחות יומיים ותקופתיים

**פורמטים נתמכים:**

* CSV – לצרכים תפעוליים
* JSON – לצרכי אינטגרציה
* HTML – לצפייה אנושית והפצה

**מאפיינים:**

* שכבת Template נפרדת
* אפשרות להוספת פורמטים נוספים

---

### 3.6 Presentation Layer

#### 3.6.1 Dashboard פנימי

* הצגת KPIs מרכזיים
* גרפים השוואתיים בין תקופות
* חיווי חריגות

#### 3.6.2 חיבור לכלי ניטור חיצוניים

* חשיפה באמצעות API
* ללא תלות בלוגיקה הפנימית

---

## 4. דרישות לא פונקציונליות

* ביצועים: תמיכה בנפחי מידע גדולים
* סקיילביליות: הוספת מקורות גיבוי נוספים
* תחזוקתיות: קוד קריא ומתועד
* בדיקות: Unit + Integration Tests

---

## 5. אבני דרך (High-Level)

1. ייצוב שכבת הסיווג
2. הרחבת מנגנון ההשוואות (כולל חודשים)
3. שיפור זיהוי חריגות
4. השלמת HTML Reports
5. שדרוג Dashboard
6. הכנה לאינטגרציות חיצוניות

---

## 6. הערות לסביבת פיתוח

* שפת פיתוח: בהתאם למימוש הקיים (Backend-centric)
* תיעוד: Markdown + Diagrams
* ניהול משימות: ייצוא ישיר ל־Cursor Tasks

---

**סטטוס המסמך:** בסיס ליישום והפקת משימות פיתוח

---

## 9. תוכנית עבודה מפורטת (Task Breakdown ל‑Cursor)

### עקרונות עבודה מול Cursor

* כל משימה היא **אטומית, ניתנת לבדיקה ומבודדת**.
* אין קפיצה בין משימות ללא סימון השלמה.
* כל משימה כוללת:

  * מטרה ברורה
  * תוצרים צפויים
  * בדיקות (Validation / Tests)
* הפיתוח מנוהל כך שיכול להתבצע על פני **מספר סשנים ומספר סוכנים**.

### ניהול סטטוס

* לכל משימה קיים סטטוס:

  * TODO
  * IN_PROGRESS
  * DONE
  * VERIFIED
* בסיום כל סשן חובה לעדכן סטטוס.

---

### Epic 1 – תשתית ו‑Core Framework

#### Task 1.1 – הקמת שלד פרויקט

**מטרה:** יצירת מבנה פרויקט בסיסי ומודולרי.

**תוצרים:**

* Repository מאותחל
* חלוקה למודולים (loader / classifier / processor / reports / ui / integrations)

**בדיקות:**

* הפרויקט עולה ללא שגיאות
* כל מודול נטען עצמאית

---

### Epic 2 – Data Ingestion

#### Task 2.1 – JSON Loader

**מטרה:** קריאת קבצי JSON כ‑input אחיד.

**תוצרים:**

* Loader גנרי
* סכימת JSON מתועדת

**בדיקות:**

* קבצים תקינים נטענים
* קבצים שגויים מזוהים

---

### Epic 3 – Backup Classification Layer

#### Task 3.1 – מנגנון סיווג גיבויים

**מטרה:** שכבת סיווג נפרדת וברורה.

**תוצרים:**

* Classifier עצמאי
* אפשרות להוספת סוגים חדשים ללא שינוי לוגיקה קיימת

**בדיקות:**

* סיווג נכון לפי חוקים
* הרחבה ללא רגרסיה

---

### Epic 4 – Processing & Analytics

#### Task 4.1 – חישובי משכי גיבוי

**מטרה:** חישוב מדויק של זמני גיבוי.

**בדיקות:**

* חישוב נכון גם במקרי קצה

#### Task 4.2 – השוואות בין תקופות

**מטרה:** תמיכה ביום/שבוע/חודש.

**בדיקות:**

* השוואות עקביות

#### Task 4.3 – זיהוי חריגות

**מטרה:** זיהוי חריגות היסטוריות.

**בדיקות:**

* חריגות מזוהות
* False positives מינימליים

---

### Epic 5 – Reporting

#### Task 5.1 – דוחות JSON / CSV

#### Task 5.2 – דוחות HTML

**מטרה:** דוח קריא להצגה.

**בדיקות:**

* HTML תקין
* נתונים תואמים למקור

---

### Epic 6 – UI Dashboard

#### Task 6.1 – Dashboard בסיסי

**מטרה:** הצגת נתונים ויזואלית.

**בדיקות:**

* טעינה תקינה
* סינון עובד

---

### Epic 7 – Integrations

#### Task 7.1 – API לקריאה חיצונית

**מטרה:** חיבור UI וכלי ניטור ללא תלות בלוגיקה.

**בדיקות:**

* API יציב
* אין תלות בין שכבות

---

### Epic 8 – QA & Validation

#### Task 8.1 – בדיקות אוטומטיות

**מטרה:** יציבות בין סשנים.

**בדיקות:**

* כל בדיקה עוברת

---

### Epic 9 – ניהול פיתוח רב‑סשני

#### Task 9.1 – מנגנון תיעוד סטטוס

**מטרה:** לאפשר המשך עבודה בין סוכנים.

**תוצרים:**

* STATUS.md
* רשימת משימות עדכנית

---

סיום מסמך משימות.
